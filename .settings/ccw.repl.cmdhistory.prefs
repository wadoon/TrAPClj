cmdhistory=["2" "(load-file \\"src/trapclj/combinatorics\\")" "(load-file \\"trapclj/combinatorics\\")" "(.getAbsolutePath (new java.io.File \\".\\"))" "(load-file \\"src/trapclj/combinatorics.clj\\")" "(ns trapclj.combinatorics)" "(ns\\n  \#^{\:author \\"Mark Engelberg\\",\\n     \:doc \\"Efficient, functional algorithms for generating lazy\\nsequences for common combinatorial functions. (See the source code \\nfor a longer description.)\\"}\\n  trapclj.combinatorics)" "(combinations (range 20) 3)" "(in-ns 'trapclj.core)\\n\\n(defn state? [s]\\n  (instance? State s))\\n(in-ns 'trapclj.combinatorics)" ";; Switching to trapclj.core namespace" "(def pg (dfa '(p q) '(\\\\a \\\\b) '( (p \\\\a p) (q \\\\a q) (p \\\\b q) (q \\\\b p) ) 'p '(q)))" "(state 'p)" "(state 'quo\\n       )" "(def a (new Dea))" "(add-state a 'p)" "\\n(defn add-state [fa s]\\n  (.addState fa (state s))" "\\n(defn add-state [fa s]\\n  (.addState fa (state s)))" "(add-state a 'p)" "(def pg (dfa '(p q) '(\\\\a \\\\b) '( (p \\\\a p) (q \\\\a q) (p \\\\b q) (q \\\\b p) ) 'p '(q)))" "(add-state a 'q)" "(add-char a \\\\a)" "(add-char a \\\\b\\n          )" "(add-transition 'p \\\\a 'q)" "(add-transition a \\n                'p \\\\a 'q)" "(add-transition a \\n                'q \\\\b 'q)" "(start-state a)" "(.removeState a (start-state a))" "(start-state\! a 'p)" "(.removeState a (start-state a))" "(.removeState a (state 'q0))" "(states a)" "(def pg (dfa '(p q) '(\\\\a \\\\b) '( (p \\\\a p) (q \\\\a q) (p \\\\b q) (q \\\\b p) ) 'p '(q)))" "(def a (new Dea))" "(start-state\! a 'p)" "\\n(defn dfa\\n  ([filename]\\n    (println \\"load from file \\" filename)\\n    (dfa-from-file filename))\\n  \\n  ([states sigma delta start acceptable]\\n    (let [dea (new Dea)]\\n      (doseq [s states] (add-state dea s)\\n        (doseq [c sigma]  (add-char dea c))\\n        (doseq [d delta]          \\n          (add-transition\\n            dea (nth d 0) (nth d 1) (nth d 2)))\\n        (let [oldstart (start-state dea)]\\n          (start-state\! dea start)\\n          (.removeState dea oldstart))\\n        (doseq [f acceptable] (.addAcceptingState dea (state f)))\\n        dea))))" "\\n(def pg (dfa '(p q) '(\\\\a \\\\b) '( (p \\\\a p) (q \\\\a q) (p \\\\b q) (q \\\\b p) ) 'p '(q)))\\n" "(defn dfa\\n  ([filename]\\n    (println \\"load from file \\" filename)\\n    (dfa-from-file filename))\\n  \\n  ([states sigma delta start acceptable]\\n    (let [dea (new Dea)]\\n      (doseq [s states] (add-state dea s)\\n        (doseq [c sigma]  (add-char dea c))\\n        (doseq [d delta]          \\n          (println \\n            dea (nth d 0) (nth d 1) (nth d 2)))\\n        (let [oldstart (start-state dea)]\\n          (start-state\! dea start)\\n          (.removeState dea oldstart))\\n        (doseq [f acceptable] (.addAcceptingState dea (state f)))\\n        dea))))" "(def pg (dfa '(p q) '(\\\\a \\\\b) '( (p \\\\a p) (q \\\\a q) (p \\\\b q) (q \\\\b p) ) 'p '(q)))" "(defn dfa\\n  ([filename]\\n    (println \\"load from file \\" filename)\\n    (dfa-from-file filename))  \\n  ([states sigma delta start acceptable]\\n    (let [dea (new Dea)]\\n      (doseq [s states] (add-state dea s)\\n        (doseq [c sigma]  (add-char dea c))\\n        (doseq [d delta]          \\n          (println dea (nth d 0) (nth d 1) (nth d 2))\\n          (add-transition dea (nth d 0) (nth d 1) (nth d 2)))\\n        (let [oldstart (start-state dea)]\\n          (start-state\! dea start)\\n          (.removeState dea oldstart))\\n        (doseq [f acceptable] (.addAcceptingState dea (state f)))\\n        dea))))\\n" "(def pg (dfa '(p q) '(\\\\a \\\\b) '( (p \\\\a p) (q \\\\a q) (p \\\\b q) (q \\\\b p) ) 'p '(q)))" "(def S \\"(a+b+c)\\")" "(def S \\"(a+b+c)\\")\\n(def sth-base (map regex \\n                   (list (str S \\\\a S \\\\b S \\\\c S)\\n                         (str S \\\\b S \\\\a S \\\\c S)\\n                         (str S \\\\c S \\\\a S \\\\b S)\\n                         (str S \\\\b S \\\\c S \\\\a S)\\n                         (str S \\\\c S \\\\b S \\\\a S)\\n                         (str S \\\\a S \\\\c S \\\\b S))))" "sth-base" "           \\n(def ddh-base (map regex (list \\n                           (str \\\\a \\\\a S \\\\b S \\\\c)\\n                           (str \\\\b \\\\a S \\\\b S \\\\c)\\n                           (str \\\\c \\\\a S \\\\b S \\\\c)\\n                           (str \\\\a \\\\b S \\\\b S \\\\c)\\n                           (str \\\\a \\\\c S \\\\b S \\\\c)\\n                           (str \\\\b \\\\b S \\\\b S \\\\c)\\n                           (str \\\\c \\\\c S \\\\b S \\\\c)\\n                           (str \\\\b \\\\c S \\\\b S \\\\c)\\n                           (str \\\\c \\\\b S \\\\a S \\\\b)\\n                           (str \\\\a \\\\b S \\\\c S \\\\b)\\n                           (str \\\\a \\\\c S \\\\a S \\\\c)\\n                           (str \\\\a \\\\c S \\\\c S \\\\c))))\\n\\n                           " "ddh-base" "\\n(defn boolean-closure [languages]\\n  (let [ l (concat\\n             languages\\n             (map dfa-complement languages)) ]\\n    (concat l\\n            (map (fn [t] \\n                   (dfa-intersection (first t) (second t)))                                    \\n                 (trapclj.combinatorics/combinations l 2))\\n            (map (fn [t] \\n                   (dfa-union (first t) (second t)))\\n                 (trapclj.combinatorics/combinations l 2)))))" "(def sth-base (map dfa-from-regex\\n                   (list (str S \\\\a S \\\\b S \\\\c S)\\n                         (str S \\\\b S \\\\a S \\\\c S)\\n                         (str S \\\\c S \\\\a S \\\\b S)\\n                         (str S \\\\b S \\\\c S \\\\a S)\\n                         (str S \\\\c S \\\\b S \\\\a S)\\n                         (str S \\\\a S \\\\c S \\\\b S))))" "                         \\n(def ddh-base (map dfa-from-regex (list \\n                           (str \\\\a \\\\a S \\\\b S \\\\c)\\n                           (str \\\\b \\\\a S \\\\b S \\\\c)\\n                           (str \\\\c \\\\a S \\\\b S \\\\c)\\n                           (str \\\\a \\\\b S \\\\b S \\\\c)\\n                           (str \\\\a \\\\c S \\\\b S \\\\c)\\n                           (str \\\\b \\\\b S \\\\b S \\\\c)\\n                           (str \\\\c \\\\c S \\\\b S \\\\c)\\n                           (str \\\\b \\\\c S \\\\b S \\\\c)\\n                           (str \\\\c \\\\b S \\\\a S \\\\b)\\n                           (str \\\\a \\\\b S \\\\c S \\\\b)\\n                           (str \\\\a \\\\c S \\\\a S \\\\c)\\n                           (str \\\\a \\\\c S \\\\c S \\\\c))))\\n" "\\n(defn boolean-closure [languages]\\n  (let [ l (concat\\n             languages\\n             (map dfa-complement languages)) ]\\n    (concat l\\n            (map (fn [t] \\n                   (dfa-intersection (first t) (second t)))                                    \\n                 (trapclj.combinatorics/combinations l 2))\\n            (map (fn [t] \\n                   (dfa-union (first t) (second t)))\\n                 (trapclj.combinatorics/combinations l 2)))))" "(boolean-closure sth-base)" "(def a (boolean-closure sth-base))" "(alength a)" "(length a)" "(import de.fhtrier.trap.models.automata.visualmodel.VisualEA)" "(defn save-fa [fa name]\\n  (let [model (new VisualEA name fa)\\n        filename (new java.io.File (str name \\".xml\\"))]\\n    (. saveAutomata SaveModel model filename)))\\n  \\n" "(import '(de.fhtrier.trap.utils LoadModel SaveModel))\\n" "(defn save-fa [fa name]\\n  (let [model (new VisualEA name fa)\\n        filename (new java.io.File (str name \\".xml\\"))]\\n    (. SaveModel saveAutomata model filename)))\\n  " "a" "(save-fa (first a) \\"test\\")" "(save-fa (first a) \\"test2\\")" "(defn enumerate \\n  [s]   (enumerate s 0)\\n  [s n] (cons (list (first s) n)\\n              (enumerate (rest s) (+ 1 n))))\\n" "(defn enumerate \\n  ([s]   (enumerate s 0))\\n  ([s n] (cons (list (first s) n)\\n              (enumerate (rest s) (+ 1 n)))))" "(enumerate '(a b c d e))" "(defn enumerate \\n  ([s]   (enumerate s 0))\\n  ([s n] \\n    (loop [ (s s)  (n n) ]\\n      (cons (list (first s) n)\\n            (recur (rest s) (+ 1 n))))))" "\\n(defn enumerate \\n  ([s]   (enumerate s 0))\\n  ([s n] \\n    (loop [ s s  n n ]\\n      (cons (list (first s) n)\\n            (recur (rest s) (+ 1 n))))))" "(defn enumerate \\n  ([s]   (enumerate s 0))\\n  ([s n] \\n    (cons (list (first s) n)\\n              (enumerate (rest s) (+ 1 n)))))" "(enumerate '(a b c d e))" "(defn enumerate \\n  ([s]   (enumerate s 0))\\n  ([s n] \\n    (if s\\n      (cons (list (first s) n)\\n            (enumerate (rest s) (+ 1 n)))\\n      nil)))" "(enumerate '(a b c d e))" "(defn enumerate \\n  ([s]   (enumerate s 0))\\n  ([s n] \\n    (if (not (empty? s))\\n      (cons (list (first s) n)\\n            (enumerate (rest s) (+ 1 n)))\\n      nil)))" "(enumerate '(a b c d e))" "\\n\\n(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenationN)]\\n    (doseq [a (enumerate automaton)] \\n      (.setParameter alg (second a) (first a)))\\n    (.run alg)\\n    (first (.getResult alg))))" "(dfa-concat-n (first a) (second a) (nth a 3))" "(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenationN)]\\n    (doseq [a (enumerate automaton)] \\n      (.setParameter alg (first a) (second a)))\\n    (.run alg)\\n    (first (.getResult alg))))\\n      " "(dfa-concat-n (first a) (second a) (nth a 3))" "(enumerate (list (first a) (second a) (nth a 3)))" "(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (reduce (fn [x y]              \\n              (.setParameter x 0)\\n              (.setParameter y 1)              \\n              (.run alg)  \\n              (first (.getResult alg))))))" "(enumerate (list (first a) (second a) (nth a 3)))" "(dfa-concat-n (first a) (second a) (nth a 3))" "\\n(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (reduce (fn [x y]              \\n              (.setParameter alg x 0)\\n              (.setParameter alg y 1)              \\n              (.run alg)  \\n              (first (.getResult alg)))\\n            automaton)))\\n      " "(dfa-concat-n (first a) (second a) (nth a 3))" "(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nea->dea (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))" "\\n(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nfa->dfa (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))" "(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nfa->dfa (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))" "(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nfa->dfa (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))\\n    \\n    " "(ns trapclj.core)\\n\\n(import '(de.fhtrier.trap.algorithms.implementation.deaalgorithms\\n           DeaComplement\\n           DeaDecideEmptiness\\n           DeaDecideFiniteness\\n           DeaDecidePermutationFree\\n           DeaDecidePermutationFreeHelp\\n           DeaDeleteNotReachable\\n           DeaDeleteUnnecessaryStates\\n           DeaDeterministicCompletion\\n           DeaDotDepthB05\\n           DeaDotDepthL05\\n           DeaIntersection\\n           DeaInverseHomomorphism\\n           DeaMinimization\\n           DeaMirror\\n           DeaToNea\\n           DeaToRegEx\\n           DeaUnion\\n           ValidateDea))\\n\\n(import '(de.fhtrier.trap.algorithms.implementation.eneaalgorithms\\n           ENeaConcatenation\\n           ENeaConcatenationN\\n           ENeaDeleteNotReachable\\n           ENeaIntersection\\n           ENeaIteration\\n           ENeaMirror\\n           ENeaToNea\\n           ENeaUnion))\\n\\n(import '(de.fhtrier.trap.algorithms.implementation.neaalgorithms\\n           NeaConcatenation\\n           NeaConcatenationN\\n           NeaDeleteNotReachable\\n           NeaIntersection\\n           NeaIteration\\n           NeaMirror\\n           NeaToDea\\n           NeaToENea\\n           NeaUnion))\\n\\n(import '(de.fhtrier.trap.algorithms.implementation.regExp\\n           CachedRegExMatcher\\n           RegExHomomorphism\\n           RegExMatcher\\n           RegExMirror\\n           RegExToENea\\n           RegExToNea))\\n\\n(import '(de.fhtrier.trap.models.regExp.mathmodel RegExParser))\\n(import '(de.fhtrier.trap.models.automata.mathmodel State Dea Nea ENea))\\n(import '(de.fhtrier.trap.utils LoadModel SaveModel))\\n(import '(de.fhtrier.trap.models.utilities CharToken))\\n(import de.fhtrier.trap.models.automata.visualmodel.VisualEA)\\n\\n\\n(defn alpha-list-n [n]\\n  (map symbol (map str (take n \\"abcdefghijklmnopqrstuvwxyz\\"))))\\n\\n(defmacro generate-operation [cls arity]\\n  (let [alg-sym (gensym)]\\n    `(fn [~@(alpha-list-n arity)]\\n       (let [~alg-sym (new ~cls)]\\n         ~@(map\\n             (fn [n a] `(.setParameter ~alg-sym ~a ~n))\\n             (range arity) (alpha-list-n arity))\\n         (.run ~alg-sym)\\n         (first (.getResult ~alg-sym))))))\\n\\n(defn dfa? [automaton]\\n  (instance? Dea automaton))\\n\\n(defn nfa? [automaton]\\n  (instance? Nea automaton))\\n\\n(defn enfa? [automaton]\\n  (instance? ENea automaton))\\n\\n(defn get-alphabet [string]\\n  (char-array\\n    (remove (fn [x] (or\\n                      (\= x \\\\))\\n                      (\= x \\\\()\\n                      (\= x \\\\*)\\n                      (\= x \\\\+)\\n                      (\= x \\\\\u20AC)))\\n      (distinct string))))\\n\\n(defn regex [input]\\n  (.parse (new RegExParser) input (get-alphabet input)))\\n\\n\\n\\n\\n\\n\\n(def dfa-complement (generate-operation DeaComplement 1))\\n(def dfa-decide-emptiness (generate-operation DeaDecideEmptiness 1))\\n(def dfa-decide-finiteness (generate-operation DeaDecideFiniteness 1))\\n(def dfa-decide-permutationfree (generate-operation DeaDecidePermutationFree 1))\\n(def dfa-delete-not-reachable (generate-operation DeaDeleteNotReachable 1))\\n(def dfa-delete-unnecessary-states (generate-operation DeaDeleteUnnecessaryStates 1))\\n(def dfa-ddh-12 (generate-operation DeaDotDepthB05 1))\\n(def dfa-sth-12 (generate-operation DeaDotDepthL05 1))\\n(def dfa-intersection (generate-operation DeaIntersection 2))\\n(def dfa-inverse-homorphism (generate-operation DeaInverseHomomorphism 1))\\n(def dfa-minimization (generate-operation DeaMinimization 1))\\n(def dfa-mirror (generate-operation DeaMirror 1))\\n(def dfa->nfa (generate-operation DeaToNea 1))\\n(def dfa->regex (generate-operation DeaToRegEx 1))\\n(def dfa-union (generate-operation DeaUnion 2))\\n(def dfa-validate (generate-operation ValidateDea 1))\\n\\n\\n(def enfa-concat (generate-operation ENeaConcatenation 2))\\n(def enfa-concat-3 (generate-operation ENeaConcatenationN 3))\\n(def enfa-concat-4 (generate-operation ENeaConcatenationN 4))\\n(def enfa-concat-5 (generate-operation ENeaConcatenationN 5))\\n(def enfa-concat-6 (generate-operation ENeaConcatenationN 6))\\n(def enfa-delete-not-reachable (generate-operation ENeaDeleteNotReachable 1))\\n(def enfa-intersection (generate-operation ENeaIntersection 2))\\n(def enfa-iteration (generate-operation ENeaIteration 1))\\n(def enfa-mirror (generate-operation ENeaMirror 1))\\n(def enfa->nea (generate-operation ENeaToNea 1))\\n(def enfa-union (generate-operation ENeaUnion 2))\\n\\n(def nfa-concat (generate-operation NeaConcatenation 2))\\n(def nfa-concat-3 (generate-operation NeaConcatenationN 3))\\n(def nfa-concat-4 (generate-operation NeaConcatenationN 4))\\n(def nfa-concat-5 (generate-operation NeaConcatenationN 5))\\n(def nfa-concat-6 (generate-operation NeaConcatenationN 6))\\n(def nfa-delete-not-reachable (generate-operation NeaDeleteNotReachable 1))\\n(def nfa-intersection (generate-operation NeaIntersection 1))\\n(def nfa-iteration (generate-operation NeaIteration 1))\\n(def nfa-mirror (generate-operation NeaMirror 1))\\n(def nfa->dfa (generate-operation NeaToDea 1))\\n(def nfa->enea (generate-operation NeaToENea 1))\\n(def nfa-union (generate-operation NeaUnion 1))\\n\\n\\n(def regex-mirror (generate-operation RegExMirror 1))\\n(def regex->enea (generate-operation RegExToENea 1))\\n(def regex->nea (generate-operation RegExToNea 1))\\n\\n\\n\\n(defn dfa-from-file [filename]\\n  (. LoadModel loadFile (new java.io.File filename) nil))\\n\\n(defn char-token? [obj]\\n  (instance? CharToken obj))\\n\\n(defn state? [s]\\n  (instance? State s))\\n\\n(defn state [obj]\\n  (if (state? obj)\\n    obj\\n    (new State (str obj))))\\n\\n\\n(defn char-token [char]\\n  (if (char-token? char) char\\n    (new CharToken char)))\\n\\n\\n(defn dfa-from-regex [regx]\\n  (nfa->dea (regex->nea (regex regx))))\\n\\n(defn states [automaton]\\n  (map (fn [x] x)\\n       (.getAllStates automaton)))\\n\\n(defn transitions [automaton]\\n  (map (fn [t]\\n         (list (.getStartState t)\\n               (.getToken t)\\n               (.getEndState t)))\\n       (.getAllTransitions automaton)))\\n\\n(defn add-state [fa s]\\n  (.addState fa (state s)))\\n\\n(defn add-char [fa c]\\n  (.addCharToken fa (char-token c)))\\n\\n(defn add-transition [fa from sym to]\\n  (.addTransition fa\\n    (state from) (char-token sym) (state to)))\\n\\n(defn start-state [a]\\n  (.getStartState a))\\n\\n(defn start-state\! [fa s]\\n  (.setStartState fa (state s)))\\n\\n(defn save-fa [fa name]\\n  (let [model (new VisualEA name fa)\\n        filename (new java.io.File (str name \\".xml\\"))]\\n    (. SaveModel saveAutomata model filename)))\\n  \\n\\n(defn dfa\\n  ([filename]\\n    (println \\"load from file \\" filename)\\n    (dfa-from-file filename))  \\n  ([states sigma delta start acceptable]\\n    (let [dea (new Dea)]\\n      (doseq [s states]   (add-state dea s)\\n        (doseq [c sigma]  (add-char dea c))\\n        (doseq [d delta]          \\n          (println dea (nth d 0) (nth d 1) (nth d 2))\\n          (add-transition dea (nth d 0) (nth d 1) (nth d 2)))\\n        (let [oldstart (start-state dea)]\\n          (start-state\! dea start)\\n          (.removeState dea oldstart))\\n        (doseq [f acceptable] (.addAcceptingState dea (state f)))\\n        dea))))\\n\\n\\n;;(def pg (dfa '(p q) '(\\\\a \\\\b) '( (p \\\\a p) (q \\\\a q) (p \\\\b q) (q \\\\b p) ) 'p '(q)))\\n\\n(defn enumerate \\n  ([s]   (enumerate s 0))\\n  ([s n] \\n    (if (not (empty? s))\\n      (cons (list (first s) n)\\n            (enumerate (rest s) (+ 1 n)))\\n      nil)))\\n  \\n\\n(defn dfa-concat-n [& rest]\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nfa->dfa (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))\\n    \\n    \\n    \\n    \\n;\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\\n;\=\=\= Hierachies\\n;\=\=\=\\n;\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\\n\\n(defn gensyms [amount]\\n  (map (fn [x] (gensym)) (range amount)))\\n\\n(defn loops-fn [var loop-vars  body]\\n  (if (empty? loop-vars)\\n    body\\n    `(doseq [~(first loop-vars) ~var])\\n    (~(loops-fn var (rest loop-vars) body))))\\n\\n\\n(defn boolean-closure [languages]\\n  (let [ l (concat\\n             languages\\n             (map dfa-complement languages)) ]\\n    (concat l\\n            (map (fn [t] \\n                   (dfa-intersection (first t) (second t)))                                    \\n                 (trapclj.combinatorics/combinations l 2))\\n            (map (fn [t] \\n                   (dfa-union (first t) (second t)))\\n                 (trapclj.combinatorics/combinations l 2)))))\\n\\n(defn concat-closure-until-length [luanges amount]\\n  (mapcat (fn [i]\\n            (concat-closure-length languages i))))\\n\\n(defn concat-closure-length [languages amount]\\n  (let [symbols (gensyms amount)]\\n    (eval (loops-fn 'languages\\n                    symbols\\n                    (cons 'fa-concat-n symbols)))))\\n\\n\\n(def S \\"(a+b+c)\\")\\n(def sth-base (map dfa-from-regex\\n                   (list (str S \\\\a S \\\\b S \\\\c S)\\n                         (str S \\\\b S \\\\a S \\\\c S)\\n                         (str S \\\\c S \\\\a S \\\\b S)\\n                         (str S \\\\b S \\\\c S \\\\a S)\\n                         (str S \\\\c S \\\\b S \\\\a S)\\n                         (str S \\\\a S \\\\c S \\\\b S))))\\n                         \\n(def ddh-base (map dfa-from-regex (list \\n                           (str \\\\a \\\\a S \\\\b S \\\\c)\\n                           (str \\\\b \\\\a S \\\\b S \\\\c)\\n                           (str \\\\c \\\\a S \\\\b S \\\\c)\\n                           (str \\\\a \\\\b S \\\\b S \\\\c)\\n                           (str \\\\a \\\\c S \\\\b S \\\\c)\\n                           (str \\\\b \\\\b S \\\\b S \\\\c)\\n                           (str \\\\c \\\\c S \\\\b S \\\\c)\\n                           (str \\\\b \\\\c S \\\\b S \\\\c)\\n                           (str \\\\c \\\\b S \\\\a S \\\\b)\\n                           (str \\\\a \\\\b S \\\\c S \\\\b)\\n                           (str \\\\a \\\\c S \\\\a S \\\\c)\\n                           (str \\\\a \\\\c S \\\\c S \\\\c))))\\n                          " "(dfa-concat-n (first a) (second a) (nth a 3))" "\\n(defn concat-closure-length [languages amount]\\n  (let [symbols (gensyms amount)]\\n    (eval (loops-fn 'languages\\n                    symbols\\n                    (cons 'fa-concat-n symbols)))))" "\\n(defn concat-closure-until-length [languages amount]\\n  (mapcat (fn [i]\\n            (concat-closure-length languages i))\\n          languages))\\n\\n" "(concat-closure-until-length sth-base 3)" "(defn concat-closure-length [languages amount]\\n  (map dfa-concat-n \\n       (trapclj.combinatorics/combinations languages amount)))" "(concat-closure-until-length sth-base 3)" "(defn concat-closure-until-length [languages amount]\\n  (concat l (mapcat (fn [i] (concat-closure-length languages i))\\n                    languages)))" "(defn concat-closure-until-length [languages amount]\\n  (concat l (mapcat (fn [i] (concat-closure-length languages i))\\n                    (range amount))))" "(defn concat-closure-until-length [languages amount]\\n  (concat languages (mapcat (fn [i] (concat-closure-length languages i))\\n                            (range amount))))" "(concat-closure-until-length sth-base 3)" "sth-base" "\\n\\n(defn dfa-concat-n [& rest]\\n  (println rest)\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nfa->dfa (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))\\n    " "(concat-closure-until-length sth-base 3)" "(defn dfa-concat-n [& rest]\\n  (println rest)\\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nfa->dfa (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))" "(concat-closure-until-length sth-base 3)" "(apply dfa-concat-n sth-base)" "(concat-closure-length sth-base 3)" "(defn concat-closure-length [languages amount]\\n  (map (fn [x] (apply dfa-concat-n x)) \\n       (trapclj.combinatorics/combinations languages amount)))\\n  " "(concat-closure-length sth-base 3)" "(defn concat-closure-length [languages amount]  \\n  (mapcat (fn [x] (apply dfa-concat-n x)) \\n       (trapclj.combinatorics/combinations languages amount)))\\n" "(concat-closure-length sth-base 3)" "(defn concat-closure-length [languages amount]  \\n  (flatten \\n    (map (fn [x] (apply dfa-concat-n x)) \\n         (trapclj.combinatorics/combinations languages amount))))" "(concat-closure-length sth-base 3)" "(defn dfa-concat-n [& rest]  \\n  (let [automaton (map dfa->nfa rest)\\n        alg (new NeaConcatenation)]\\n    (nfa->dfa (reduce (fn [x y]              \\n                        (.setParameter alg x 0)\\n                        (.setParameter alg y 1)              \\n                        (.run alg)  \\n                        (first (.getResult alg)))\\n                      automaton))))\\n" "(concat-closure-length sth-base 3)" "\\n(defn level52 [base]\\n  (concat-closure-until-length ;5/2\\n    (boolean-closure ;2\\n      (concat-closure-until-length ; 3/2 \\n        (boolean-closure ;1\\n          base) ;1/2\\n                                   4)) 3))" "(def r (level52 sth-base))" "(defn concat-closure-until-length [languages amount]\\n  (concat languages (mapcat (fn [i] (concat-closure-length languages i))\\n                            (range 2 amount))))" "(defn level52 [base]\\n  (concat-closure-until-length ;5/2\\n    (boolean-closure ;2\\n      (concat-closure-until-length ; 3/2 \\n        (boolean-closure ;1\\n          base) ;1/2\\n                                   4)) 3))\\n" "(def r (level52 sth-base))" "2" "(load-file \\"src/trapclj/trapclj.core.clj\\")" "(load-file \\"src/trapclj/core.clj\\")" "(load-file \\"src/trapclj/combinatorics.clj\\")" "(load-file \\"src/trapclj/core.clj\\")" "(in-ns 'trapclj.core)\\n(defn level1 [lc]\\n  (boolean-closure lc))\\n\\n(defn level32 [lc]\\n  (concat-closure-until-length (level1 lc) 4))\\n\\n(defn level2 [lc]\\n (boolean-closure (level32 lc)))\\n\\n(defn level 52 [lc]\\n  (concat-closure-until-length (level2 lc) 4))\\n\\n(in-ns 'user)" ";; Switching to trapclj.core namespace" "(defn level1 [lc]\\n  (boolean-closure lc))\\n\\n(defn level32 [lc]\\n  (concat-closure-until-length (level1 lc) 4))\\n\\n(defn level2 [lc]\\n (boolean-closure (level32 lc)))\\n\\n(defn level 52 [lc]\\n  (concat-closure-until-length (level2 lc) 4))\\n \\n\\n\\n" "(defn level2 [lc]\\n (boolean-closure (level32 lc)))\\n" "                  \\n(defn level1 [lc]\\n  (boolean-closure lc))\\n\\n(defn level32 [lc]\\n  (concat-closure-until-length (level1 lc) 4))\\n" "(defn level 52 [lc]\\n  (concat-closure-until-length (level2 lc) 4))\\n" "(defn level52 [lc]\\n  (concat-closure-until-length (level2 lc) 4))\\n" "(level1 sth-base)" "(level2\\n  sth-base)" "(def r (level52 sth-base))"]
eclipse.preferences.version=1
